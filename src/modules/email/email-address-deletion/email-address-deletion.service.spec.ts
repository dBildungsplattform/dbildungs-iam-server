import { createMock, DeepMocked } from '@golevelup/ts-jest';
import { Test, TestingModule } from '@nestjs/testing';
import { ClassLogger } from '../../../core/logging/class-logger.js';
import { EmailAddressDeletionService } from './email-address-deletion.service.js';
import { EmailRepo } from '../persistence/email.repo.js';
import { EventRoutingLegacyKafkaService } from '../../../core/eventbus/services/event-routing-legacy-kafka.service.js';
import { PersonRepository } from '../../person/persistence/person.repository.js';
import { EmailAddress, EmailAddressStatus } from '../domain/email-address.js';
import { faker } from '@faker-js/faker';
import { Person } from '../../person/domain/person.js';
import { PersonID } from '../../../shared/types/aggregate-ids.types.js';
import { PersonPermissions } from '../../authentication/domain/person-permissions.js';
import assert from 'assert';
import { OXUserID } from '../../../shared/types/ox-ids.types.js';

const EMAIL_ADDRESSES_DELETE_LIMIT: number = 10;

describe('EmailAddressDeletionService', () => {
    let module: TestingModule;
    let sut: EmailAddressDeletionService;

    let emailRepoMock: DeepMocked<EmailRepo>;
    let personRepositoryMock: DeepMocked<PersonRepository>;
    let eventServiceMock: DeepMocked<EventRoutingLegacyKafkaService>;
    let loggerMock: DeepMocked<ClassLogger>;

    beforeAll(async () => {
        module = await Test.createTestingModule({
            providers: [
                EmailAddressDeletionService,
                {
                    provide: ClassLogger,
                    useValue: createMock<ClassLogger>(),
                },
                {
                    provide: PersonRepository,
                    useValue: createMock<PersonRepository>(),
                },
                {
                    provide: EmailRepo,
                    useValue: createMock<EmailRepo>(),
                },
                {
                    provide: EventRoutingLegacyKafkaService,
                    useValue: createMock<EventRoutingLegacyKafkaService>(),
                },
            ],
        }).compile();

        sut = module.get(EmailAddressDeletionService);

        emailRepoMock = module.get(EmailRepo);
        personRepositoryMock = module.get(PersonRepository);
        eventServiceMock = module.get(EventRoutingLegacyKafkaService);
        loggerMock = module.get(ClassLogger);
    });

    /**
     * Returns an EmailAddress. If no person is provided, address  will be generated by faker,
     * same is true for oxUserId, updatedAt default is 180 days in the past.
     * @param status
     * @param person
     * @param updatedAt
     */
    function createEmailAddress(
        status: EmailAddressStatus,
        oxUserId: OXUserID | undefined,
        person: Person<true> | undefined,
        updatedAt?: Date,
    ): EmailAddress<true> {
        const dateInPast: Date = new Date();
        dateInPast.setDate(dateInPast.getDate() - 180);
        const emailAddress: EmailAddress<true> = createMock<EmailAddress<true>>({
            get status(): EmailAddressStatus {
                return status;
            },
            get address(): string {
                if (person) {
                    return person.vorname + '.' + person.familienname + '@schule-sh.de';
                }
                return faker.internet.email();
            },
            get personId(): PersonID | undefined {
                return person?.id ?? undefined;
            },
            get oxUserID(): Option<string> {
                return oxUserId;
            },
            updatedAt: updatedAt ?? dateInPast,
        });

        return emailAddress;
    }

    function createEmailAddressesForPersons(persons: Person<true>[], status: EmailAddressStatus): EmailAddress<true>[] {
        const list: EmailAddress<true>[] = [];
        for (const person of persons) {
            const emailAddress: EmailAddress<true> = createEmailAddress(status, faker.string.numeric(), person);
            list.push(emailAddress);
        }

        return list;
    }

    function createPersons(size: number = 3): Person<true>[] {
        const list: Person<true>[] = [];
        for (let i: number = 0; i < size; i++) {
            const person: Person<true> = createMock<Person<true>>({
                id: faker.string.uuid(),
                username: faker.internet.userName(),
                vorname: faker.person.firstName(),
                familienname: faker.person.lastName(),
            });
            list.push(person);
        }

        return list;
    }

    function createPersonsAndEmailAddresses(size: number = 3): [Person<true>[], EmailAddress<true>[]] {
        const persons: Person<true>[] = createPersons(size);
        const disabledEmailAddresses: EmailAddress<true>[] = createEmailAddressesForPersons(
            persons,
            EmailAddressStatus.DISABLED,
        );
        const personWithEnabledEmailAddress: Person<true> | undefined = persons[0];
        assert(personWithEnabledEmailAddress);
        const enabledEmailAddresses: EmailAddress<true>[] = createEmailAddressesForPersons(
            [personWithEnabledEmailAddress],
            EmailAddressStatus.ENABLED,
        );

        return [persons, disabledEmailAddresses.concat(enabledEmailAddresses)];
    }

    afterAll(async () => {
        await module.close();
    });

    beforeEach(() => {
        jest.resetAllMocks();
    });

    it('should be defined', () => {
        expect(sut).toBeDefined();
    });

    describe('deleteEmailAddresses', () => {
        describe('when some EmailAddress has UNDEFINED personId', () => {
            it('should log error about that', async () => {
                const [persons, emailAddresses]: [Person<true>[], EmailAddress<true>[]] =
                    createPersonsAndEmailAddresses();
                const permissionsMock: PersonPermissions = createMock<PersonPermissions>();
                const emailAddressWithUnknownPersonId: EmailAddress<true> = createEmailAddress(
                    EmailAddressStatus.DISABLED,
                    faker.string.numeric(),
                    undefined,
                );
                emailRepoMock.getByDeletedStatusOrUpdatedAtExceedsDeadline.mockResolvedValueOnce([
                    emailAddresses.concat([emailAddressWithUnknownPersonId]),
                    emailAddresses.length + 1,
                ]);
                personRepositoryMock.findByIds.mockResolvedValueOnce(persons);

                await sut.deleteEmailAddresses(permissionsMock, EMAIL_ADDRESSES_DELETE_LIMIT);

                expect(emailRepoMock.getByDeletedStatusOrUpdatedAtExceedsDeadline).toHaveBeenCalledTimes(1);
                expect(personRepositoryMock.findByIds).toHaveBeenCalledTimes(1);
                expect(loggerMock.info).toHaveBeenCalledWith(
                    `Could NOT get information about EmailAddress when generating EmailAddressDeletedEvent because personId was UNDEFINED, address:${emailAddressWithUnknownPersonId.address}`,
                );
            });
        });

        describe('when for some EmailAddress username is UNDEFINED (map does not contain value for personId)', () => {
            it('should log error about that', async () => {
                const [persons, emailAddresses]: [Person<true>[], EmailAddress<true>[]] =
                    createPersonsAndEmailAddresses();
                const permissionsMock: PersonPermissions = createMock<PersonPermissions>();
                emailRepoMock.getByDeletedStatusOrUpdatedAtExceedsDeadline.mockResolvedValueOnce([
                    emailAddresses,
                    emailAddresses.length,
                ]);
                const removed: Person<true> | undefined = persons.pop();
                assert(removed);
                personRepositoryMock.findByIds.mockResolvedValueOnce(persons);

                await sut.deleteEmailAddresses(permissionsMock, EMAIL_ADDRESSES_DELETE_LIMIT);

                expect(emailRepoMock.getByDeletedStatusOrUpdatedAtExceedsDeadline).toHaveBeenCalledTimes(1);
                expect(personRepositoryMock.findByIds).toHaveBeenCalledTimes(1);
                expect(loggerMock.error).toHaveBeenCalledWith(
                    `Could NOT get username when generating EmailAddressDeletedEvent, personId:${removed.id}`,
                );
            });
        });

        describe('when an EmailAddress does NOT have an OxUserId', () => {
            it('should log error about that', async () => {
                const [persons, emailAddresses]: [Person<true>[], EmailAddress<true>[]] =
                    createPersonsAndEmailAddresses();
                const permissionsMock: PersonPermissions = createMock<PersonPermissions>();
                assert(persons[0]);
                const emailAddressWithoutOxUserId: EmailAddress<true> = createEmailAddress(
                    EmailAddressStatus.DISABLED,
                    undefined,
                    persons[0],
                );
                emailRepoMock.getByDeletedStatusOrUpdatedAtExceedsDeadline.mockResolvedValueOnce([
                    emailAddresses.concat([emailAddressWithoutOxUserId]),
                    emailAddresses.length + 1,
                ]);
                personRepositoryMock.findByIds.mockResolvedValueOnce(persons);

                await sut.deleteEmailAddresses(permissionsMock, EMAIL_ADDRESSES_DELETE_LIMIT);

                expect(emailRepoMock.getByDeletedStatusOrUpdatedAtExceedsDeadline).toHaveBeenCalledTimes(1);
                expect(personRepositoryMock.findByIds).toHaveBeenCalledTimes(1);
                expect(loggerMock.error).toHaveBeenCalledWith(
                    `Could NOT get oxUserId when generating EmailAddressDeletedEvent, personId:${emailAddressWithoutOxUserId.personId}`,
                );
            });
        });
    });

    describe('checkRemainingEmailAddressesByPersonId', () => {
        let personId: PersonID;
        let oxUserId: OXUserID;

        beforeEach(() => {
            personId = faker.string.uuid();
            oxUserId = faker.string.numeric();
        });

        describe('when personId is UNDEFINED in event', () => {
            it('should publish EmailAddressesPurgedEvent and KafkaEmailAddressesPurgedEvent', async () => {
                await sut.checkRemainingEmailAddressesByPersonId(undefined, oxUserId);

                expect(loggerMock.info).toHaveBeenCalledWith(
                    `PersonId UNDEFINED when checking remaining EmailAddresses for person, oxUserId:${oxUserId}`,
                );
                expect(eventServiceMock.publish).toHaveBeenCalledWith(
                    expect.objectContaining({
                        personId: undefined,
                        username: undefined,
                        oxUserId: oxUserId,
                    }),
                    expect.objectContaining({
                        personId: undefined,
                        username: undefined,
                        oxUserId: oxUserId,
                    }),
                );
            });
        });

        describe('when Person CANNOT be found', () => {
            it('should log error about that and return', async () => {
                personRepositoryMock.findById.mockResolvedValueOnce(undefined);

                await sut.checkRemainingEmailAddressesByPersonId(personId, oxUserId);

                expect(loggerMock.error).toHaveBeenCalledWith(
                    `Could not check for remaining EmailAddresses, no Person found for personId:${personId}`,
                );
                expect(eventServiceMock.publish).toHaveBeenCalledTimes(0);
            });
        });

        describe('when person has remaining EmailAddresses', () => {
            it('should not log info about NOT publishing event', async () => {
                const [persons, emailAddresses]: [Person<true>[], EmailAddress<true>[]] =
                    createPersonsAndEmailAddresses();
                assert(persons[0]);
                personRepositoryMock.findById.mockResolvedValueOnce(persons[0]);
                emailRepoMock.findByPersonSortedByUpdatedAtDesc.mockResolvedValueOnce(emailAddresses);

                await sut.checkRemainingEmailAddressesByPersonId(personId, oxUserId);

                expect(loggerMock.info).toHaveBeenCalledWith(
                    `Person has remaining EmailAddresses, WON'T publish EmailAddressesPurgedEvent, personId:${personId}, username:${persons[0].username}`,
                );
                expect(eventServiceMock.publish).toHaveBeenCalledTimes(0);
            });
        });

        describe('when person does NOT have remaining EmailAddresses', () => {
            it('should not log info about publishing event', async () => {
                const [persons]: [Person<true>[], EmailAddress<true>[]] = createPersonsAndEmailAddresses();
                assert(persons[0]);
                personRepositoryMock.findById.mockResolvedValueOnce(persons[0]);
                emailRepoMock.findByPersonSortedByUpdatedAtDesc.mockResolvedValueOnce([]);

                await sut.checkRemainingEmailAddressesByPersonId(personId, oxUserId);

                expect(loggerMock.info).toHaveBeenCalledWith(
                    `No remaining EmailAddresses for Person, publish EmailAddressesPurgedEvent, personId:${personId}, username:${persons[0].username}`,
                );
                expect(eventServiceMock.publish).toHaveBeenCalledTimes(1);
            });
        });
    });
});
